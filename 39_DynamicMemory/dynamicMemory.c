/*  메모리 동적 할당 및 관리
	- heap 영역을 사용하는 방법
	- 프로그램 실행 중 필요한 메모리를 OS에 요청(할당)해 사용하며 반환(해제)의 책임이 있음
	- 할당 받은 메모리는 쓰레기 값이 들어 있음
	- malloc() / free() > allocation : 할당 memory allocation
	
	소스코드를 개발하는 시점의 이슈 2개
	> 컴파일타임, 링크타임 (합쳐서 빌드타임)
	개발돼서 실행에 넘어간다
	> 런타임 (실행시점)
	개발할때는 런타임시점을 어느정도 예상하고 개발해야함.
	런타임 시점에 메모리가 어느정도 필요할것인가
	>> 동적할당 > 가상메모리의 힙영역(자유메모리영역) 사용, 거실같은 느낌(좀 다용도 공간)
	OS한테 요청해서 할당받아서 써야함. (요청, 반환 필요)
	어느정도 필요하다 size 필요 > OS는 지가 허용하는 범위내에서 내가 요청하면 줌
	메모리를 할당받았을때는 쓰레기값이 들어있음 > 우리는 항상 필요하다면 clear해야함.
	근데 메모리가 적으면 0초기화하는것도 좋은데 동적할당한 메모리가 예를들어 1기가다?(예를들면 동영상처리하는 프로그램)
	1기가를 전부다 0으로 초기화할게요 > 시간 상당히 오래걸릴것. > 쓰레기값이 들어있다는 걸 알고있고 코드를 작성해주면 됨
	> 클리어가 필수는 아님. > 적으면 그냥 0초기화 해주고
	다 썼어 > 반환

	malloc() > 이 함수는 위치정보(주소)를 반환함 > 그래서 반환받은 주소의 메모리공간을 잘 활용하다가
	free() > 나중에 free함수에다가 malloc으로 받은 주소를 인수로 넘겨줘야함. > 해제
*/

/*  하드웨어적 수준에서 RAM메모리를 관리하는 기법들이 여러개 있다
	관리한다 > CPU가 관리함 > 어떠한 단위로 관리함 > 1바이트는 주소를 붙이는 단위고
	어떤 덩어리 단위로 잘라서 관리함 > 얼로케이션 사이즈 : 64kb (트럭한대분량으로 음료수싣고왔다쳐)
	음료수를 한박스씩 끄집어내(페이지단위) > page : 4kb 
	내가 malloc()했다 > OS는 음료수 만드는 공장이야 > 4kb정도로 일단 끊어와
	내가 요청한게  1024 > 1kb라고 치면 3kb안썼지? > 그 뒤에 누군가가 2kb나 3kb 달라고하면
	마침 잘됐다 딱 남아 > 근데 4kb달라고하면? > 저 남은 공간을 쓸 수가 없어
	그러면 어쩔수없이 새로운 페이지 떼와야함(4kb) > 자칫 잘못하면 메모리 낭비가 됨.
*/

#include <stdio.h>
#include <stdlib.h> // malloc()을 쓰려면 이게 필요함 표준라이브러리

int main(void) {

	int* pList = NULL; // 0으로 초기화 해주고

	pList = (int*)malloc(sizeof(int) * 3);
	// sizeof연산자 > int자료형에 대한 연산을 할것이고 특별한이유없으면 4일것이고 *3이니까 12bytes가 되겠군
	// 포인터변수는 8바이트(64비트)

	// 메모리를 동적할당 > 운영체제가 텅빈공간중에 어디 한 공간을 딱 집어주는게 메모리 동적할당
	// malloc() 함수가 주소를 가져와서 반환을 할텐데 그 주소가 어딘지 몰라
	// 심지어 런타임에 결정남. malloc() 함수가 호출되면서 그 때 결정된다.
	// 그리고 포인터변수는 배열처럼 쓸 수 있었지?
	// int가 3개니까 인덱스가 2까지 가게 이런식으로 쓸 수 있다 즉,
	
	/*  malloc으로 메모리를 연속으로 할당받았기 때문에
		포인터 변수 pList를 배열처럼 사용 가능하다.
		복잡한 *(pList + 0) = 10; 대신
		pList[0] = 10; 처럼 배열 표기법을 사용하면 된다.
	*/

	pList[0] = 10; // *(pList + 0) = 10; 과 똑같지 (역참조 방식 : 그 주소에 있는 값을 가져오기)
	// 근데 
	pList[1] = 20;
	pList[2] = 30;
	// 디버그모드일때 메모리 보통 보다보면 메모리동적할당하면 cd cd cd라고 보통 들어가있고
	// 지역변수같은거는 메모리가 생기면 거기 cc cc cc cc 들어가있다(쓰레기값)
	// 동적할당한 메모리 앞뒤로 보통 fd fd fd  이런값들이 보임.(쓰레기값)
	// 디버그 모드해서 &pList 0으로 클리어되는거 f10으로 가면서 확인하고
	// pList 주소창에 쳐서 f10으로 가면서 cd cd cd cd cd cd cd cd cd cd cd cd 에 4개씩(int니까)
	// 값이 10, 20, 30 들어갈때 바뀌는 것 확인.
	// 
	// 자 여기서 굉장히 중요한 개념
	// *****메모리 주소창에 &pList / pList 차이???*****
	// 1. &pList는 포인터변수 pList 자체의 주소를 의미. 즉, pList라는 변수가 스택 메모리에서 저장된 위치임.
	// 여기에는 8바이트(64비트 시스템 기준)가 할당되어 있고, 처음에는 NULL(0)fh chrlghk ehla.
	// 2. pList는 엠얼록으로 할당받은 힙 메모리의 시작 주소를 의미함.
	// 이 주소는 엠얼록이 반환한 메모리 공간의 시작점임.
	// 여기에는 12바이트(sizeof(int)*3)가 할당되어 있고, 처음에는 쓰레기값(cd cd cd ...)가 들어가 있음.
	// 즉 &pList는 포인터변수의 주소고 pList는 할당받은 동적 할당된 메모리공간의 시작주소를 가리킴
	// 쉽게 말해 그냥 포인터개념이잖아
	// pList는 포인터변수이고
	// &pList는 그 포인터변수가 어디있는지
	// pList는 포인터변수니까(주소를 가리키는) pList가 가리키는 곳(엠얼록으로 동적할당받은 곳)을 보여주고

	// 포인터변수 pList를 배열처럼 엑세스해서 값을 출력하겠다 > 당연히 잘 나오겠지
	for (int i = 0; i < 3; ++i)
		printf("%d\n", pList[i]);

	// 메모리 다 썼으면 반납해라
	// 디버그모드에서 f10으로 보면 아까 fd fd fd fd 있던자리 포함해서 훨씬 많이 빨갛게 됨.
	// 내부적으로는 메모리가 뭔가 바뀌고 그럼. > 이거는 나중에 따로 공부해봐
	free(pList);

	return 0;
}

/*  엠얼록으로 메모리할당받은건 인티저3개인데 pList[3] = 40; 주고
	프린트문에  i < 4 를 했다? >> 결과는 10 20 30 40 잘나와
	근데 디버그모드에서 프로그램을 개발하게되면 free()에서 죽음
	HEAP CORRUPTION DETECTED라고 오류뜨면서 죽음.
	동적할당받은 힙메모리를 썼는데 그게 커럽션이 났다.
	C언어가 자유도가 높아서 이런 문제가 생길수도
	컴파일러 시점에서 안알려줌.
	이런 문제를 겪을때 메모리 디버그 빌드 할때 free할때 저런 오류가 난다?
	내가 쓸 수 있는 경계를 넘어서 뭔가 메모리를 write 했을 때 나오는 전형적인 특징임.
	메모리가 동적할당했을 때, 즉 pList라는 이름의 변수 속에 동적할당된 메모리 주소가 있지
	초기화 시키고 값 들어갈때 넘어갈때 배열의 제일 끝에 fd fd fd (Canary bit) 가 손상됨
	write하면 안되는 곳에 write 했다는 걸 write할 때 모름
	>> 운영체제한테 반납할때 free 함수가 내부적으로 canary bit 위치를 조사했더니
	거기에 overwrite가 돼서 fdfdfd가 아니고 다른 값이 들어갔다 > 이상하다고 에러내는 것.
	pList[3] = 0xFDFDFDFD;를 하면? 안죽어
*/