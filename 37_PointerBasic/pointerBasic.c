/*  포인터 변수
	포인터는 변수다.
	기존의 변수랑 뭐가 다른가? > 메모리의 주소를 저장하기 위한 전용 변수
	포인터변수에 메모리의 주소를 저장하겠다.

	64비트 시스템에서 주소 상수, 포인터 변수는 모두 64비트 - 8바이트
	캐릭터 하나가 8비트-1바이트인데 거기에 부여하는 주소는 64비트 주소를 부여한다.
	1바이트마다 64비트가 어태치 되어서 붙어있는게 아니라 그런 큰 숫자를 붙여서 그걸 관리하겠다는것이지
	1바이트마다 64비트가 붙어있는게 아님. 관리하는 쪽에서 64비트 체계를 쓰는 것일 뿐이라는 것.
	절대 1바이트에 64비트가 딱 붙어있는게 아닌걸 명심해.

	>> 별것도 아닌걸 더럽게 어렵게 강의하네
	>> 쉽게말해 그냥 주소의 크기와 실제 저장 공간의 크기는 별개의 개념.
	>> 왜 64비트 주소를 사용할까?
	>> 더 많은 메모리 공간을 '관리'할 수 있도록
	>> 32비트 > 최대4기가 / 64비트 > 이론상 16엑사바이트(약1600만 테라바이트)까지 관리가능

	 char ch = 'A';
	 char* pszData = &ch
	 >> pszData는 변수인데 얘 자료형은 기본적으로 캐릭터포인터인거고
	 >> 그 속에는 주소가 들어있고 그 주소를 따라가보면 어떤 공간이 있는데
	 >> 그 공간을 캐릭터형이라고 해석하려고 해. 라는 뜻 (char*)
	 무엇에 대한 포인터이냐? > 캐릭터에 대한 포인터

	 위치정보, 주소정보가 저장된다 포인터변수에는 > 시작점 위치정보(주소정보)
	 이 주소를 따라가면(간접지정하게되면) 그 결과는 char형이다 뭐 그런식

	 직접지정과 간접지정
	 - 직접지정 : 변수 선언할때 int data; 라고 선언을 했다고 쳤을때
				운영체제가 알아서 data의 4바이트짜리 메모리를 잡아줌 (예를들어 엑셀셀을 떠올려서 C6부터 4칸(4바이트)이라 치자)
				주소 C6을 상수형태로 기술해서 콕 집어서 저기를 이제부터 인티저형으로 해석할거고 이름은 data야 > 직접지정

	 - 간접지정 : B8번에 C6이라고 써있어
				C6이라는데는 이름이 data인 메모리 영역이잖아
				근데 B8위치에 C6위치정보가 또 들어가있는거
				그러니까 B8은 포인터가 되는 것.
				그 포인터 변수를 통해서 특정 위치를 지정해서 거기를 뭔가로 해석하겠다 >> 간접지정

		** 그냥 쉽게 말해서 특정 메모리 공간을 예를들어 int로 지정할 때
		* 상수로 지정하면 직접 지정
		* 포인터 변수로 지정하면 간접 지정
*/

#include <stdio.h>

int main(void) {

	int nData = 10;
	// 문자열상수 > 첫글자가 저장된 메모리의 주소 > 첫글자부터 널나올때까지 쭉 따라가서 그걸 화면에 출력

	int* pnData = &nData;

	printf("%s\n", "nData"); // char[6] >> nData\0 >> 읽기전용 문자배열 > 문자열 상수 > 실행코드영역 > data section(read only)

	printf("%d\n", nData); // 이거 디버그모드로 F10으로 실행했다가 다시 디버그모드로 실행해보면 메모리 주소가 달라(실행할때마다)
	// > 메모리주소 > 실행했을때 결정 > ASLR때문(운영체제의 보안적이유) : 어드레스 스페이스 레이아웃을 랜덤으로 결정
	// > 스택, 힙, 스태틱 등 이런 메모리들의 위치들이 실행시킬때마다 다르게 나오고 자꾸 바뀜
	// > 왜 이렇게? > 실행할때마다 바꿔놔야 함부로 조작을 못함.
	// > 내 캐릭터 체력이 있다(unsigned int겠지?) > 내가 어떤 캐릭이 있는데 내 컴퓨터 상의 메모리 어딘가에는 unsigned int하나가 있고
	// 거기에 체력정보가 있을것임 > 내가 그 위치를 찾아내서 가서 1~100까지 있는 체력을 100만으로 바꿔 > 안죽겠지
	// 주소만 알면 끝장나는거지 핵은 이런거 하는거
	// ASLR은 주소특정을 어렵게 만드는 것.

	printf("%p\n", &nData); // 이름이 nData인 메모리의 주소 > %p > 주소형식

	return 0;
}

/*  일반 포인터와 참조/역참조
	int a = 10; > 변수 a를 선언하고 10을 저장
	int* pa = &a; > 포인터 pa를 선언하고 a의 주소를 저장
	
	printf("%d", a); > 10
	printf("%p", &a); > 0x########
	printf("%p", pa); > 0x########
	printf("%d", *pa); > 10 //여기서 *는 역참조 연산자 : 포인터pa가 가리키는 메모리의 값을 얻을 때 사용

	// 역참조도 내나 포인터변수에 대한 간접지정으로 거기를 따라가는거지
	// 그래서 간접지정하면은 *pa의 형식이 int에 대한 포인터 int*이니까 int 변수가 되는 것.
	// 그러면 그 포인터를 따라가서 거기에 20을 저장하게 되겠지 (*pa = 20; 을 했다 쳤을때)
	
*/