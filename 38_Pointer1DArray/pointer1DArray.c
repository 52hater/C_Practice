/*  포인터와 1차원 배열
	- 배열을 이루는 요소 형식에 대한 포인터 변수를 선언하는 것이 일반적
	- char []는 char* 로 관리
	- int []는 int* 로 관리
	- 간접 지정 연산(*)의 결과는 형식이 있는 변수로 생각할 수 있음

	열을 설정하고 맨앞의 기준으로부터 몇 칸 떨어져있는지? > 인덱스(기준과의 상대적 위치)
	어떤 배열에서는 첫번째요소 즉 기준요소가 되는곳에 위치정보인 주소가 있고
	주소는 상수고 주소상수에 식별자가 부여된다.
	
	배열 > 요소자료형 생각
	char szData[5] = {"data"}; 이렇게 선언 및 정의를 했다고 가정하면
	이 때 szData라고 하는 식별자의 자료형은 char [5] 캐릭터가 5개있는 배열이지
	이것의 포인터를 지정하면 1번요소 하나 char* > 캐릭터를 가리킬 수 있는 포인터, 즉 캐릭터에 대한 포인터가 되는 것.
	이렇게 배열의 이름을 식별자로 저장하려면 캐릭터 포인터 변수를 선언해서 저장하면 됨.
	이 둘은 거의 완벽하게 호환이 됨 > 1차원 배열, 포인터 >>> 섞어서 이것저것 쓸 줄 알아야함.
	**cf) 포인터와 배열의 한가지 중요한 차이점 :
	- 배열명은 상수 포인터로 값을 변경할 수 없지만(aList = &someVar; 불가능)
	- 포인터 변수는 다른 주소를 가리키도록 변경이 가능함(pnData = &someVar; 가능)

	간접지정연산(*)
	char* pszData = 주소; > pszData라는 포인터변수에 * 붙여서 *pszData > 이때 얘가 바로 간접지정연산이 됨.
	간접지정 > 변수가 있는데 그 변수가 가리키는 곳을 어떠한 자료형으로 해석하기로 했어 (간접지정)
	1차원배열에 대한 포인터 싱글포인터인경우 LValue는 포인터로 떨어진다
	>> *(char*) >> ** 없애고 char 남아 > 캐릭터형이 됨
	>> *pszData > 캐릭터 변수가 됨 (간접지정 해버리는 순간) > *pszData = 'A'; 이럴 수 있는거지
	
	포인터와 1차원 배열
	- 포인터 변수나 배열 이름에 대해 덧셈, 뺄셈 연산을 할 수 있음 (곱, 나눗은 안됨)
	- 이 덧셈, 뺄셈은 산술 연산이 아니라 상대 위치를 계산하기 위한 연산이며 배열요소의 개수를 의미 (기준+3 > 위치가 특정)
	>> 어떤 포인터 변수를 기준점으로 두고 거기에 대해서 상대 위치를 계산하는 연산 (보통 덧셈, 경우에 따라 단항증가 많이 함)
	- 포인터 변수에 대해서는 단항 증/감 연산도 가능

	+1을 한다치면 이걸 한 개로 해석해라
	예를들어 캐릭터배열이면 한 개 > 한칸 옆쪽 > 주소가 1바이트만큼 증가 (캐릭터 한개만큼)
	인트배열이면? > 4바이트만큼 증가하겠지 (인터한개만큼)
	쇼트배열이면? > 2바이트만큼 증가하겠지 (쇼트한개만큼)
*/

#include <stdio.h>

int main(void) {

	int aList[5] = { 0 };
	// 배열은 포인터처럼 첫요소의 주소를 가리킨댔잖아. ********배열이름은 자체로 첫번째 요소의 주소를 의미함!!!!********
	int* pnData = aList; // 포인터에 aList라고 저장 > aList라는것 자체가 기준요소의 주소니까 아랫줄과 같다. 이 표현을 더 많이 씀
	//int *pnData = &aList[0];
	// 위의 두 줄 다 배열의 첫 번째 요소의 주소를 가리킴, pnData는 int 하나(4바이트)씩 이동할 수 있는 포인터가 됨.
	// 
	// ****************근데 int* pnData = &aList; 는 다름. ***************
	// &aList는 "배열 전체"의 주소를 의미하며, 타입이 int(*pArr)[5]가 됨.(5개의 int로 구성된 배열에 대한 포인터)
	// 따라서 int* pnData = &aList;는 타입 불일치로 컴파일 에러가 발생함.

	// 포인터연산에서는 int 일때 pa+1 > 4바이트만큼 이동 / pArr+1 > 20바이트만큼 이동(int(*pArr)[5]라면)
	// 여기서(*pArr)[5]의 괄호는 필수임.괄호가 없으면 int* pArr[5]가 되어버리는데,
	// 이는 "int 포인터 5개로 구성된 배열"이라는 전혀 다른 의미가 됨
	// int(*pArr)[5] > 배열을 가리키는 포인터
	// int pArr[5] > int포인터 5개로 구성된 배열

	// 배열포인터를 쓰는 주된 이유 > 2차원배열을 함수의 매개변수로 전달할때, 여러 개의 동일한 크기의 배열을 다룰 때
	// 2차원 배열을 함수의 매개변수로 전달 받는 예시
	/* void printArray(int (*arr)[3], int rows) {  // 3열짜리 2차원 배열을 받는 함수
			for(int i = 0; i < rows; i++) {
				for(int j = 0; j < 3; j++) {
					printf("%d ", arr[i][j]);
				}
					 printf("\n");
			}
		}

	int main() {
		int arr[2][3] = {{1,2,3}, {4,5,6}};
		printArray(arr, 2);
		return 0;
	} */

	printf("aList[0] : %d\n", aList[0]);

	*pnData = 20;
	printf("aList[0] : %d\n", aList[0]); //싱글레벨어레이와
	printf("pnData[0] : %d\n", pnData[0]); //싱글포인터는 완전히 호환이 된다.
	// 간접지정하면은 *pnData의 형식이 int에 대한 포인터 int*이니까 int 변수가 되는 것.
	// 그러면 그 포인터를 따라가서 거기에 20을 저장하게 되겠지 (*pnData = 20;)


	char szBuffer[16] = { "Hello" };
	char* pszData = szBuffer; // 이 시점에서 pszData는 'H'가 저장된 메모리 위치를 가리킴(배열의 첫번째 요소주소로 초기화)

	// 조건문이 거짓이 될 때 까지 반복
	while (*pszData != '\0') // 간접지정의 결과는 변수 > 첨에 저장된 값 h겠지 (역참조>값을 가져옴) / 널문자 만날때까지 반복
		pszData++; // 주소값 + 1 > H > e > l > l > o > \0 (char에 대한 포인터니까 char한개만큼 +인거지(+1)) / **이걸 저장하는거지**
	// 기준주소보다 5만큼 증가했지 (루프가 끝난 후의 위치(널문자위치))
	// 근데 pszData 변수에 주소값을 저장한다는 코드가 하나도 없는것같은데
	// >> pszData++는 실제로 포인터변수 pszData에 저장된 주소값을 1 증가시키는 것.
	// 별도의 주소값 저장 코드가 없어도 ++연산자가 pszData의 주소값을 직접 변경하는 것.
	// 이것이 포인터의 장점 중 하나임 - 주소값을 직접 조작
	// 포인터일때 ++는 자료형의 크기만큼 증가
	// 어쨌거나 이 루프가 끝나는 시점에서는 pszData가 \0의 주소값이 되어있겠지

	/*  int num = 5;
		while(num < 8) {
			printf("%d ", num);  // 5 6 7 출력
			num++;             
		} >> 끝나는 이 시점에서 num = 8 인것처럼
	*/

	printf("&pszData : %p, &szBuffer : %\n",
		pszData, szBuffer);
	// pszData : 루프가 끝난 후의 위치(널문자위치)
	// szBuffer : 배열의 시작위치
	// 두 주소 값을 16진수 형태로 출력

	printf("Length : %d\n", pszData - szBuffer); // 5가 나오겠지 > 문자열의 길이가 되는것이지.("Hello"의 길이)
	// pszData - szBuffer >> 두 포인터의 차이를 계산
	// 시작위치에서 현재위치까지의 거리 = 문자열 길이
	// 루프돌아서 널이 나올때까지 재는 방식으로 문자열의 길이를 잰다.
	// >> 실제로 C표준 라이브러리의 strlen()함수가 동작하는 방식과 유사함.

	return 0;
}