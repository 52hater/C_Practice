#include <stdio.h>

/* 사용자로부터 점수(0~100)를 입력 받아 80점 이상이면 '합격',
   그렇지 않으면 '불합격' 이라고 출력하는 프로그램을 작성.
   단, 반드시 3항 연산자를 사용*/

int main(void) {

	int score = 0;
	scanf_s("%d", &score);

	/*printf("score : %d\n%s\n", score,
		score < 0 || score > 100 ? "0 ~ 100까지의 점수를 입력하시오" :
		score >= 80 ? "합격" : "불합격");*/
		// 위에 코드는 가독성이 너무 떨어지니까 로직과 출력을 분리해보자

		// 3항 연산자를 변수에 저장하여 가독성 향상
		// char* 는 문자열(문자"배열")을 가리키는 포인터 > "합격", "불합격" 등의 문자열을 저장. (문자열이니까 캐릭터)
		// char* result 는 문자배열의 시작 주소를 가리키는 포인터지.
		// const 는 상수를 의미하는 키워드, 변경불가 > result가 가리키는 문자열이 변경되지 않도록 보호
		// 문자배열을 가리키는 포인터 result를 선언하는데 그 배열의 값(문자열)은 변경할 수 없다는것
		// 괄호는 안쳐도 되지만 연산자 우선순위가 명확해지도록 써주자. 연산자 우선순위를 명확히 하는 곳에만 써주자.
	const char* result =
		(score < 0 || score > 100) ? "0 ~ 100까지의 점수를 입력하시오" :
		(score >= 80 ? "합격" : "불합격");
	// 여기에 goto를 한 번 활용해 볼 수 있지 않을까???
	// 0~100의 범위를 벗어나는 인풋이 들어갔을때 다시 입력하는 행위로 치환되도록
	// 강제로 흐름을 바꾸는 goto 잘 쓰이는 일은 없지만 필요하면 써야지
	// goto 쓰는 건 무섭지만 조건없는 goto만 쓰지않는다면 고려해 볼 수도
	// 여전히 유효성체크나 리소스반환(OS에게?) 같은 그런것에는 쓰일수도있다

	printf("score : %d\n%s\n", score, result);

	return 0;
}

// 공부해놔
/*   1. const의 위치에 따른 차이
	const char* ptr;    // ptr이 가리키는 문자열을 수정할 수 없음
	char* const ptr;    // ptr 자체를 다른 주소로 변경할 수 없음
	const char* const ptr;  // 둘 다 수정할 수 없음

	 2. static - 정적 변수 선언 키워드
	static int count = 0;  // 함수가 끝나도 값이 유지됨

	 3. volatile - 최적화 방지 키워드
	volatile int sensor_val;  // 컴파일러의 최적화를 막음

	4. register - 레지스터 변수 선언 키워드
	register int counter;  // 빠른 접근을 위해 CPU 레지스터에 저장 요청 */